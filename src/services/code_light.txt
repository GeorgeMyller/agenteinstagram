
║ ■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
║ ▶ src/services/send.py
║ ■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■

import os
import time
from dotenv import load_dotenv
from evolutionapi.client import EvolutionClient
from evolutionapi.models.message import TextMessage, MediaMessage
class MessageSender:
    def __init__(self) -> None:
        load_dotenv()
        self.evo_api_token = os.getenv("EVO_API_TOKEN")
        self.evo_instance_id = os.getenv("EVO_INSTANCE_NAME")
        self.evo_instance_token = os.getenv("EVO_INSTANCE_TOKEN")
        self.evo_base_url = os.getenv("EVO_BASE_URL")
        self.client = EvolutionClient(
            base_url=self.evo_base_url,
            api_token=self.evo_api_token
        )
    def send_text(self, number, msg, mentions=[]):
        text_message = TextMessage(
            number=str(number),
            text=msg,
            mentioned=mentions
        )
        time.sleep(10)
        response = self.client.messages.send_text(
            self.evo_instance_id, 
            text_message, 
            self.evo_instance_token
        )
        return response
    def send_pdf(self, number, pdf_file, caption=""):
        if not os.path.exists(pdf_file):
            raise FileNotFoundError(f"Arquivo '{pdf_file}' não encontrado.")
        media_message = MediaMessage(
            number=number,
            mediatype="document",
            mimetype="application/pdf",
            caption=caption,
            fileName=os.path.basename(pdf_file),
            media=""
        )
        self.client.messages.send_media(
            self.evo_instance_id, 
            media_message, 
            self.evo_instance_token,
            pdf_file
        )
    def send_audio(self, number, audio_file):
        if not os.path.exists(audio_file):
            raise FileNotFoundError(f"Arquivo '{audio_file}' não encontrado.")
        audio_message = {
            "number": number,
            "mediatype": "audio",
            "mimetype": "audio/mpeg",
            "caption": ""
        }
        self.client.messages.send_whatsapp_audio(
            self.evo_instance_id,
            audio_message,
            self.evo_instance_token,
            audio_file
        )
        return "Áudio enviado"
    def send_image(self, number, image_file, caption=""):
        if not os.path.exists(image_file):
            raise FileNotFoundError(f"Arquivo '{image_file}' não encontrado.")
        media_message = MediaMessage(
            number=number,
            mediatype="image",
            mimetype="image/jpeg",
            caption=caption,
            fileName=os.path.basename(image_file),
            media=""
        )
        self.client.messages.send_media(
            self.evo_instance_id, 
            media_message, 
            self.evo_instance_token,
            image_file
        )
        return "Imagem enviada"
    def send_video(self, number, video_file, caption=""):
        if not os.path.exists(video_file):
            raise FileNotFoundError(f"Arquivo '{video_file}' não encontrado.")
        media_message = MediaMessage(
            number=number,
            mediatype="video",
            mimetype="video/mp4",
            caption=caption,
            fileName=os.path.basename(video_file),
            media=""
        )
        self.client.messages.send_media(
            self.evo_instance_id, 
            media_message, 
            self.evo_instance_token,
            video_file
        )
        return "Vídeo enviado"
    def send_document(self, number, document_file, caption=""):
        if not os.path.exists(document_file):
            raise FileNotFoundError(f"Arquivo '{document_file}' não encontrado.")
        media_message = MediaMessage(
            number=number,
            mediatype="document",
            mimetype="application/vnd.openxmlformats-officedocument.wordprocessingml.document",
            caption=caption,
            fileName=os.path.basename(document_file),
            media=""
        )
        self.client.messages.send_media(
            self.evo_instance_id, 
            media_message, 
            self.evo_instance_token,
            document_file
        )
        return "Documento enviado"
sender = MessageSender()
celular = "120363391798069472@g.us"
sender.send_text(number=celular,
                  msg="teste de mensagem")
║ ■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
║ ▶ src/services/__init__.py
║ ■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■


║ ■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
║ ▶ src/services/message.py
║ ■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■

import base64
class Message:
    TYPE_TEXT = "conversation"
    TYPE_AUDIO = "audioMessage"
    TYPE_IMAGE = "imageMessage"
    TYPE_DOCUMENT = "documentMessage"
    TYPE_VIDEO = "videoMessage"
    SCOPE_GROUP = "group"
    SCOPE_PRIVATE = "private"
    def __init__(self, raw_data):
        if "data" not in raw_data:
            enveloped_data = {
                "event": None,
                "instance": None,
                "destination": None,
                "date_time": None,
                "server_url": None,
                "apikey": None,
                "data": raw_data  # Todo o conteúdo simples vai para 'data'
            }
        else:
            enveloped_data = raw_data
        self.data = enveloped_data
        self.extract_common_data()
        self.extract_specific_data()
    def extract_common_data(self):
        """Extrai os dados comuns e define os atributos da classe."""
        self.event = self.data.get("event")
        self.instance = self.data.get("instance")
        self.destination = self.data.get("destination")
        self.date_time = self.data.get("date_time")
        self.server_url = self.data.get("server_url")
        self.apikey = self.data.get("apikey")
        data = self.data.get("data", {})
        key = data.get("key", {})
        self.remote_jid = key.get("remoteJid")
        self.message_id = key.get("id")
        self.from_me = key.get("fromMe")
        self.push_name = data.get("pushName")
        self.status = data.get("status")
        self.instance_id = data.get("instanceId")
        self.source = data.get("source")
        self.message_timestamp = data.get("messageTimestamp")
        self.message_type = data.get("messageType")
        self.sender = data.get("sender")  # Disponível apenas para grupos
        self.participant = key.get("participant")  # Número de quem enviou no grupo
        self.determine_scope()
    def determine_scope(self):
        """Determina se a mensagem é de grupo ou privada e define os atributos correspondentes."""
        if self.remote_jid.endswith("@g.us"):
            self.scope = self.SCOPE_GROUP
            self.group_id = self.remote_jid.split("@")[0]  # ID do grupo
            self.phone = self.participant.split("@")[0] if self.participant else None  # Número do remetente no grupo
        elif self.remote_jid.endswith("@s.whatsapp.net"):
            self.scope = self.SCOPE_PRIVATE
            self.phone = self.remote_jid.split("@")[0]  # Número do contato
            self.group_id = None  # Não é aplicável em mensagens privadas
        else:
            self.scope = "unknown"  # Tipo desconhecido
            self.phone = None
            self.group_id = None
    def extract_specific_data(self):
        """Extrai dados específicos e os define como atributos da classe."""
        if self.message_type == self.TYPE_TEXT:
            self.extract_text_message()
        elif self.message_type == self.TYPE_AUDIO:
            self.extract_audio_message()
        elif self.message_type == self.TYPE_IMAGE:
            self.extract_image_message()
        elif self.message_type == self.TYPE_DOCUMENT:
            self.extract_document_message()
        elif self.message_type == self.TYPE_VIDEO:
            self.extract_video_message()
    def extract_text_message(self):
        """Extrai dados de uma mensagem de texto e define como atributos."""
        self.text_message = self.data["data"]["message"].get("conversation")
    def extract_audio_message(self):
        """Extrai dados de uma mensagem de áudio e define como atributos da classe."""
        audio_data = self.data["data"]["message"]["audioMessage"]
        self.audio_base64_bytes = self.data["data"]["message"].get("base64")
        self.audio_url = audio_data.get("url")
        self.audio_mimetype = audio_data.get("mimetype")
        self.audio_file_sha256 = audio_data.get("fileSha256")
        self.audio_file_length = audio_data.get("fileLength")
        self.audio_duration_seconds = audio_data.get("seconds")
        self.audio_media_key = audio_data.get("mediaKey")
        self.audio_ptt = audio_data.get("ptt")
        self.audio_file_enc_sha256 = audio_data.get("fileEncSha256")
        self.audio_direct_path = audio_data.get("directPath")
        self.audio_waveform = audio_data.get("waveform")
        self.audio_view_once = audio_data.get("viewOnce", False)
    def extract_image_message(self):
        """Extrai dados de uma mensagem de imagem e define como atributos."""
        image_data = self.data["data"]["message"]["imageMessage"]
        self.image_url = image_data.get("url")
        self.image_mimetype = image_data.get("mimetype")
        self.image_caption = image_data.get("caption")
        self.image_file_sha256 = image_data.get("fileSha256")
        self.image_file_length = image_data.get("fileLength")
        self.image_height = image_data.get("height")
        self.image_width = image_data.get("width")
        self.image_media_key = image_data.get("mediaKey")
        self.image_file_enc_sha256 = image_data.get("fileEncSha256")
        self.image_direct_path = image_data.get("directPath")
        self.image_media_key_timestamp = image_data.get("mediaKeyTimestamp")
        self.image_thumbnail_base64 = image_data.get("jpegThumbnail")
        self.image_scans_sidecar = image_data.get("scansSidecar")
        self.image_scan_lengths = image_data.get("scanLengths")
        self.image_mid_quality_file_sha256 = image_data.get("midQualityFileSha256")
        self.image_base64 = self.data["data"]["message"].get("base64")
    def extract_document_message(self):
        """Extrai dados de uma mensagem de documento e define como atributos da classe."""
        document_data = self.data["data"]["message"]["documentMessage"]
        self.document_url = document_data.get("url")
        self.document_mimetype = document_data.get("mimetype")
        self.document_title = document_data.get("title")
        self.document_file_sha256 = document_data.get("fileSha256")
        self.document_file_length = document_data.get("fileLength")
        self.document_media_key = document_data.get("mediaKey")
        self.document_file_name = document_data.get("fileName")
        self.document_file_enc_sha256 = document_data.get("fileEncSha256")
        self.document_direct_path = document_data.get("directPath")
        self.document_caption = document_data.get("caption", None)
        self.document_base64_bytes = self.decode_base64(self.data["data"]["message"].get("base64"))
    def extract_video_message(self):
        """Extrai dados de uma mensagem de vídeo e define como atributos da classe."""
        video_data = self.data["data"]["message"]["videoMessage"]
        self.video_url = video_data.get("url")
        self.video_mimetype = video_data.get("mimetype")
        self.video_caption = video_data.get("caption")
        self.video_file_sha256 = video_data.get("fileSha256")
        self.video_file_length = video_data.get("fileLength")
        self.video_height = video_data.get("height")
        self.video_width = video_data.get("width")
        self.video_media_key = video_data.get("mediaKey")
        self.video_file_enc_sha256 = video_data.get("fileEncSha256")
        self.video_direct_path = video_data.get("directPath")
        self.video_media_key_timestamp = video_data.get("mediaKeyTimestamp")
        self.video_seconds = video_data.get("seconds")
        self.video_streaming_sidecar = video_data.get("streamingSidecar")
        self.video_thumbnail_base64 = video_data.get("jpegThumbnail")
        self.video_gif_playback = video_data.get("gifPlayback", False)
        self.video_view_once = video_data.get("viewOnce", False)
        self.video_base64 = self.data["data"]["message"].get("base64")
    def decode_base64(self, base64_string):
        """Converte uma string base64 em bytes."""
        if base64_string:
            return base64.b64decode(base64_string)
        return None
    def get(self):
        """Retorna todos os atributos como um dicionário."""
        return self.__dict__
    def get_text(self):
        """Retorna o texto da mensagem, dependendo do tipo."""
        text = ""
        if self.message_type == self.TYPE_TEXT:
            text = self.text_message
        elif self.message_type == self.TYPE_IMAGE:
            text = self.image_caption
        elif self.message_type == self.TYPE_DOCUMENT:
            text = self.document_caption
        elif self.message_type == self.TYPE_VIDEO:
            text = self.video_caption
        return text
    def get_name(self):
        """Retorna o nome do remetente."""
        return self.push_name
    @staticmethod
    def get_messages(messages):
        """Retorna uma lista de objetos `Message` a partir de uma lista de mensagens."""
        msgs = messages['messages']['records']
        mensagens = []
        for msg in msgs:
            mensagens.append(Message(msg))
        return mensagens
║ ■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
║ ▶ src/services/post_queue.py
║ ■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■

import os
import time
import uuid
import threading
import logging
from queue import Queue, Empty
from threading import Thread
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(name)s - %(levelname)s - %(message)s')
logger = logging.getLogger('PostQueue')
class ContentPolicyViolation(Exception):
    """Exceção para violações de política de conteúdo"""
class RateLimitExceeded(Exception):
    """Exceção para limites de taxa excedidos"""
class PostStatus:
    """Enum-like class to represent post status values"""
    PENDING = "pending"
    PROCESSING = "processing"
    COMPLETED = "completed"
    FAILED = "failed"
    RATE_LIMITED = "rate_limited"
    POLICY_VIOLATION = "policy_violation"
class PostQueue:
    """
    Sistema de filas para processamento assíncrono de posts e reels
    """
    def __init__(self):
        """Inicializa o sistema de filas"""
        self.job_queue = Queue()
        self.jobs = {}  # Armazena informações sobre os trabalhos
        self.job_history = []  # Histórico de trabalhos
        self.stats = {
            "total_jobs": 0,
            "completed_jobs": 0,
            "failed_jobs": 0,
            "rate_limited_posts": 0,
            "video_processing_jobs": 0,
            "image_processing_jobs": 0,
            "avg_processing_time": 0
        }
        self.worker_thread = None
        self.is_running = False
        self.processing_lock = threading.Lock()  # Lock para operações críticas
        self.start_worker()
    def start_worker(self):
        """Inicia o thread worker para processamento de filas"""
        if not self.is_running:
            self.is_running = True
            self.worker_thread = Thread(target=self._process_queue, daemon=True)
            self.worker_thread.start()
            logger.info("Worker de processamento iniciado")
    def stop_worker(self):
        """Para o thread worker"""
        self.is_running = False
        if self.worker_thread and self.worker_thread.is_alive():
            self.worker_thread.join(timeout=5.0)
            logger.info("Worker de processamento encerrado")
    def add_job(self, media_path, caption, inputs=None) -> str:
        """
        Adiciona um novo trabalho à fila
        Args:
            media_path (str or list): Caminho do arquivo de mídia ou lista de caminhos
            caption (str): Legenda do post
            inputs (dict): Configurações adicionais
        Returns:
            str: ID do trabalho
        """
        job_id = str(uuid.uuid4())
        media_paths = media_path if isinstance(media_path, list) else [media_path]
        content_type = "image"  # default
        if inputs and "content_type" in inputs:
            content_type = inputs["content_type"]  # Use explicit content type if provided
        elif len(media_paths) > 1:
            content_type = "carrossel"
        else:
            path = media_paths[0]
            if isinstance(path, str) and path.lower().endswith(('.mp4', '.mov', '.avi', '.wmv')):
                content_type = "reel"
        job_data = {
            "id": job_id,
            "media_paths": media_paths,
            "caption": caption,
            "inputs": inputs or {},
            "status": "pending",
            "created_at": time.time(),
            "updated_at": time.time(),
            "result": None,
            "error": None,
            "content_type": content_type
        }
        for path in media_paths:
            if not os.path.isfile(path):
                raise FileNotFoundError(f"Media file not found: {path}")
        self.jobs[job_id] = job_data
        self.job_queue.put(job_id)
        with self.processing_lock:
            self.stats["total_jobs"] += 1
            if content_type == "reel":
                self.stats["video_processing_jobs"] += 1
            else:
                self.stats["image_processing_jobs"] += 1
        logger.info(f"Novo trabalho adicionado: {job_id} ({content_type})")
        return job_id
    def _process_queue(self):
        """Thread worker para processar trabalhos na fila"""
        while self.is_running:
            try:
                try:
                    job_id = self.job_queue.get(block=True, timeout=1.0)
                except Empty:
                    continue
                try:
                    logger.info(f"Processando trabalho: {job_id}")
                    job = self.jobs[job_id]
                    self._update_job_status(job_id, "processing")
                    from src.services.instagram_send import InstagramSend
                    start_time = time.time()
                    result = None
                    error = None
                    try:
                        if job["content_type"] == "reel":
                            logger.info(f"Processando vídeo para Reels: {job['media_paths'][0]}")
                            share_to_feed = True
                            if "share_to_feed" in job["inputs"]:
                                share_to_feed = job["inputs"]["share_to_feed"]
                            result = InstagramSend.send_reels(
                                job["media_paths"][0], 
                                job["caption"],
                                job["inputs"]
                            )
                        elif job["content_type"] == "carousel":
                            logger.info(f"Processando carrossel: {job['media_paths']}")
                            result = InstagramSend.send_carousel(
                                job["media_paths"], 
                                job["caption"],
                                job["inputs"]
                            )
                        else:
                            result = InstagramSend.send_instagram(
                                job["media_paths"][0], 
                                job["caption"],
                                job["inputs"]
                            )
                        if result:
                            self._update_job_status(job_id, "completed", result=result)
                            logger.info(f"Trabalho completado: {job_id}")
                            with self.processing_lock:
                                self.stats["completed_jobs"] += 1
                        else:
                            raise Exception("Falha no processamento do conteúdo")
                    except RateLimitExceeded as e:
                        error = str(e)
                        logger.warning(f"Rate limit excedido: {error}")
                        self._update_job_status(job_id, "rate_limited", error=error)
                        with self.processing_lock:
                            self.stats["rate_limited_posts"] += 1
                            self.stats["failed_jobs"] += 1
                    except ContentPolicyViolation as e:
                        error = str(e)
                        logger.warning(f"Violação de política: {error}")
                        self._update_job_status(job_id, "policy_violation", error=error)
                        with self.processing_lock:
                            self.stats["failed_jobs"] += 1
                    except Exception as e:
                        error = str(e)
                        logger.error(f"Erro no processamento: {error}")
                        self._update_job_status(job_id, "failed", error=error)
                        with self.processing_lock:
                            self.stats["failed_jobs"] += 1
                    processing_time = time.time() - start_time
                    with self.processing_lock:
                        if self.stats["completed_jobs"] > 0:
                            current_avg = self.stats["avg_processing_time"]
                            total_processed = self.stats["completed_jobs"]
                            new_avg = ((current_avg * (total_processed - 1)) + processing_time) / total_processed
                            self.stats["avg_processing_time"] = new_avg
                    self._add_to_history(job_id)
                    for media_path in job["media_paths"]:
                        self._cleanup_media(media_path)
                finally:
                    self.job_queue.task_done()
            except Exception as e:
                logger.exception(f"Erro no worker de processamento: {e}")
    def _update_job_status(self, job_id, status, result=None, error=None):
        """Atualiza o status de um trabalho"""
        if job_id in self.jobs:
            self.jobs[job_id]["status"] = status
            self.jobs[job_id]["updated_at"] = time.time()
            if result is not None:
                self.jobs[job_id]["result"] = result
            if error is not None:
                self.jobs[job_id]["error"] = error
    def _add_to_history(self, job_id):
        """Adiciona um trabalho ao histórico"""
        if job_id in self.jobs:
            job_copy = self.jobs[job_id].copy()
            MAX_HISTORY = 100
            if len(self.job_history) >= MAX_HISTORY:
                self.job_history.pop(0)  # Remover o mais antigo
            self.job_history.append(job_copy)
            self._cleanup_old_jobs()
    def _cleanup_old_jobs(self):
        """Limpa trabalhos antigos"""
        current_time = time.time()
        MAX_AGE = 24 * 60 * 60  # 24 horas
        jobs_to_remove = []
        for job_id, job in self.jobs.items():
            if current_time - job["updated_at"] > MAX_AGE:
                jobs_to_remove.append(job_id)
        for job_id in jobs_to_remove:
            if job_id in self.jobs:
                del self.jobs[job_id]
    def _cleanup_media(self, media_path):
        """Limpa arquivos de mídia temporários"""
        try:
            if os.path.exists(media_path) and os.path.basename(media_path).startswith("temp-"):
                os.remove(media_path)
                logger.info(f"Arquivo de mídia temporário removido: {media_path}")
        except Exception as e:
            logger.warning(f"Erro ao limpar arquivo temporário {media_path}: {e}")
    def get_job_status(self, job_id):
        """
        Obtém o status de um trabalho
        Args:
            job_id (str): ID do trabalho
        Returns:
            dict: Informações do trabalho
        """
        if job_id in self.jobs:
            return self.jobs[job_id].copy()
        for job in self.job_history:
            if job["id"] == job_id:
                return job.copy()
        return {"error": "Job não encontrado"}
    def get_queue_stats(self):
        """
        Obtém estatísticas da fila
        Returns:
            dict: Estatísticas da fila
        """
        with self.processing_lock:
            stats = self.stats.copy()
            stats["queue_size"] = self.job_queue.qsize()
            stats["active_jobs"] = len(self.jobs)
            return stats
    def get_job_history(self, limit=10):
        """
        Obtém histórico de trabalhos
        Args:
            limit (int): Número máximo de registros
        Returns:
            list: Histórico de trabalhos
        """
        return sorted(
            self.job_history,
            key=lambda x: x.get("updated_at", 0),
            reverse=True
        )[:limit]
    def clear_queue(self):
        """Limpa a fila atual de trabalhos"""
        while not self.job_queue.empty():
            try:
                self.job_queue.get(False)
                self.job_queue.task_done()
            except Empty:
                break
        logger.info("Fila limpa")
post_queue = PostQueue()
║ ■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
║ ▶ src/services/instagram_send.py
║ ■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■

import os
import time
import requests
from src.instagram.crew_post_instagram import InstagramPostCrew
from src.instagram.describe_image_tool import ImageDescriber
from src.instagram.instagram_post_service import InstagramPostService
from src.instagram.border import ImageWithBorder
from src.instagram.filter import FilterImage
from src.utils.paths import Paths
from src.instagram.image_uploader import ImageUploader
from src.services.post_queue import post_queue, RateLimitExceeded
class InstagramSend:
    last_rate_limit_time = 0
    rate_limit_window = 3600  # 1 hour window for rate limiting
    max_rate_limit_hits = 52  # Maximum number of rate limit hits before enforcing longer delays
    @staticmethod
    def queue_post(image_path, caption, inputs=None) -> str:
        """
        Queue an image to be posted to Instagram asynchronously
        Args:
            image_path (str): Path to the image file
            caption (str): Caption text
            inputs (dict): Optional configuration for post generation
        Returns:
            str: Job ID for tracking the post status
        """
        if not caption or caption.lower() == "none":
            caption = "A AcessoIA está transformando processos com IA! 🚀"
            print(f"Caption vazia ou 'None'. Usando caption padrão: '{caption}'")
        if not os.path.exists(image_path):
            raise FileNotFoundError(f"Arquivo de imagem não encontrado: {image_path}")
        job_id = post_queue.add_job(image_path, caption, inputs)
        return job_id
    @staticmethod
    def queue_reels(video_path, caption, inputs=None) -> str:
        """
        Queue a video to be posted to Instagram as a reel asynchronously
        Args:
            video_path (str): Path to the video file
            caption (str): Caption text
            inputs (dict): Optional configuration for post generation
        Returns:
            str: Job ID for tracking the post status
        """
        if not caption or caption.lower() == "none":
            caption = "A AcessoIA está transformando processos com IA! 🚀 #reels #ai"
            print(f"Caption vazia ou 'None'. Usando caption padrão para reels: '{caption}'")
        if not os.path.exists(video_path):
            raise FileNotFoundError(f"Arquivo de vídeo não encontrado: {video_path}")
        if inputs is None:
            inputs = {}
        inputs["content_type"] = "reel"
        inputs["video_path"] = video_path
        print(f"Caption in queue_reels: {caption}")  # Debug statement
        job_id = post_queue.add_job(video_path, caption, inputs)
        print(f"Reel queued with job ID: {job_id}")
        return job_id
    @staticmethod
    def queue_carousel(image_paths, caption, inputs=None):
        """
        Enfileira um carrossel de imagens para o Instagram
        Args:
            image_paths (list): Lista de caminhos dos arquivos de mídia (imagens)
            caption (str): Legenda do post
            inputs (dict): Configurações adicionais
        Returns:
            str: ID do trabalho
        """
        job_id = post_queue.add_job(image_paths, caption, inputs)
        return job_id
    @staticmethod
    def check_post_status(job_id):
        """
        Check the status of a queued post
        Args:
            job_id (str): Job ID returned when queuing the post
        Returns:
            dict: Job status information
        """
        return post_queue.get_job_status(job_id)
    @staticmethod
    def get_queue_stats():
        """
        Get statistics about the current queue
        Returns:
            dict: Queue statistics
        """
        return post_queue.get_queue_stats()
    @staticmethod
    def get_recent_posts(limit=10):
        """
        Get recent post history
        Args:
            limit (int): Maximum number of posts to return
        Returns:
            list: Recent post history
        """
        return post_queue.get_job_history(limit)
    @staticmethod
    def send_instagram(image_path, caption, inputs=None):
        """
        Send an image to Instagram with a caption.
        Args:
            image_path (str): Path to the image file
            caption (str): Caption text
            inputs (dict): Optional configuration for post generation
        """
        result = None
        original_image_path = image_path
        uploaded_images = []
        uploader = ImageUploader()  # Reuse the same uploader instance
        if not caption or caption.lower() == "none":
            caption = "A AcessoIA está transformando processos com IA! 🚀"
            print(f"Caption vazia ou 'None'. Usando caption padrão: '{caption}'")
        try:
            if inputs is None:
                inputs = {
                    "estilo": "Divertido, Alegre, Sarcástico e descontraído",
                    "pessoa": "Terceira pessoa do singular",
                    "sentimento": "Positivo",
                    "tamanho": "200 palavras",
                    "genero": "Neutro",
                    "emojs": "sim",
                    "girias": "sim"
                }
            if not os.path.exists(image_path):
                raise FileNotFoundError(f"Arquivo de imagem não encontrado: {image_path}")
            border_image = os.path.join(Paths.SRC_DIR, "instagram", "moldura.png")
            print("Aplicando filtros à imagem...")
            image_path = FilterImage.process(image_path)
            print("Obtendo descrição da imagem...")
            try:
                temp_image = uploader.upload_from_path(image_path)
                uploaded_images.append(temp_image)
                describe = ImageDescriber.describe(temp_image['url'])
                if temp_image.get("deletehash"):
                    print(f"Deletando imagem temporária usada para descrição...")
                    if uploader.delete_image(temp_image["deletehash"]):
                        uploaded_images.remove(temp_image)
            except Exception as e:
                print(f"Erro ao obter descrição da imagem: {str(e)}")
                describe = "Imagem para publicação no Instagram."
            print("Aplicando bordas e filtros...")
            try:
                image = ImageWithBorder.create_bordered_image(
                    border_path=border_image,
                    image_path=image_path,
                    output_path=image_path                
                )
            except Exception as e:
                print(f"Erro ao aplicar borda à imagem: {str(e)}")
            print("Enviando imagem para publicação...")
            try:
                final_image = uploader.upload_from_path(image_path)
                uploaded_images.append(final_image)
            except Exception as e:
                print(f"Erro ao fazer upload da imagem final: {str(e)}")
                raise
            print("Gerando legenda...")
            try:
                crew = InstagramPostCrew()
                inputs_dict = {
                    "genero": inputs.get('genero', 'Neutro'),
                    "caption": caption,
                    "describe": describe,
                    "estilo": inputs.get('estilo', 'Divertido, Alegre, Sarcástico e descontraído'),
                    "pessoa": inputs.get('pessoa', 'Terceira pessoa do singular'),
                    "sentimento": inputs.get('sentimento', 'Positivo'),
                    "tamanho": inputs.get('tamanho', '200 palavras'),
                    "emojs": inputs.get('emojs', 'sim'),
                    "girias": inputs.get('girias', 'sim')
                }
                final_caption = crew.kickoff(inputs=inputs_dict)  # Passar o dicionário
            except Exception as e:
                print(f"Erro ao gerar legenda: {str(e)}")
                final_caption = caption  # Usar a legenda original em caso de erro
            final_caption = final_caption + "\n\n-------------------"
            final_caption = final_caption + "\n\n Essa postagem foi toda realizada por um agente inteligente"
            final_caption = final_caption + "\n O agente desempenhou as seguintes ações:"
            final_caption = final_caption + "\n 1 - Idenficação e reconhecimento do ambiente da fotografia"
            final_caption = final_caption + "\n 2 - Aplicação de Filtros de contraste e autocorreção da imagem"
            final_caption = final_caption + "\n 3 - Aplicação de moldura específica"
            final_caption = final_caption + "\n 4 - Definição de uma persona específica com base nas preferências"
            final_caption = final_caption + "\n 5 - Criação da legenda com base na imagem e na persona"
            final_caption = final_caption + "\n 6 - Postagem no feed do instagram"
            final_caption = final_caption + "\n\n-------------------"
            print("Iniciando processo de publicação no Instagram...")
            try:
                insta_post = InstagramPostService()
                stats = post_queue.get_queue_stats()
                current_time = time.time()
                if stats["rate_limited_posts"] > InstagramSend.max_rate_limit_hits:
                    if (current_time - InstagramSend.last_rate_limit_time) < InstagramSend.rate_limit_window:
                        remaining_time = InstagramSend.rate_limit_window - (current_time - InstagramSend.last_rate_limit_time)
                        raise RateLimitExceeded(
                            f"Taxa de requisições severamente excedida. "
                            f"Aguarde {int(remaining_time/60)} minutos antes de tentar novamente."
                        )
                    else:
                        InstagramSend.last_rate_limit_time = 0
                        stats["rate_limited_posts"] = 0
                result = insta_post.post_image(final_image['url'], final_caption)
                if not result:
                    print("Falha ao publicar no Instagram. Verificando status...")
                    raise Exception("Falha na publicação")
                print("Post processado e enviado ao Instagram com sucesso!")
                return result
            except Exception as e:
                error_str = str(e).lower()
                if "rate" in error_str and "limit" in error_str:
                    InstagramSend.last_rate_limit_time = current_time
                    raise RateLimitExceeded(f"Taxa de requisições excedida: {str(e)}")
                print(f"Erro no processo de publicação no Instagram: {str(e)}")
                raise
        except Exception as e:
            print(f"Erro durante o processo de publicação: {str(e)}")
            return None
        finally:
            try:
                failed_deletions = []
                for img in uploaded_images:
                    try:
                        if img.get("deletehash"):
                            print(f"Tentando deletar imagem com deletehash: {img.get('deletehash')}...")
                            if not uploader.delete_image(img["deletehash"]):
                                failed_deletions.append(img["deletehash"])
                    except requests.exceptions.HTTPError as e:
                        if hasattr(e, 'response') and e.response.status_code == 404:
                            print("Imagem já removida do servidor.")
                        else:
                            print(f"Erro ao deletar imagem: {str(e)}")
                    except Exception as e:
                        print(f"Erro ao deletar imagem: {str(e)}")
                if failed_deletions:
                    print("Aviso: Algumas imagens não puderam ser deletadas:")
                    for failed_hash in failed_deletions:
                        print(f"- Deletehash: {failed_hash}")
                if image_path and image_path != original_image_path and os.path.exists(image_path):
                    os.remove(image_path)
                    print(f"A imagem local {image_path} foi apagada com sucesso.")
            except Exception as cleanup_error:
                print(f"Erro ao limpar arquivos temporários: {str(cleanup_error)}")
        return result
    @staticmethod
    def send_reels(video_path, caption, inputs=None):
        """
        Send a video to Instagram as a Reel
        Args:
            video_path (str): Path to the video file
            caption (str): Caption text
            inputs (dict): Optional configuration for post generation
        Returns:
            dict: Result information including post ID and URL
        """
        from src.instagram.instagram_reels_publisher import ReelsPublisher
        try:
            publisher = ReelsPublisher()
            hashtags = None
            if inputs and 'hashtags' in inputs:
                hashtags = inputs['hashtags']
            share_to_feed = True
            if inputs and 'share_to_feed' in inputs:
                share_to_feed = inputs['share_to_feed']
            result = publisher.upload_local_video_to_reels(
                video_path=video_path,
                caption=caption,
                hashtags=hashtags,
                optimize=True,  # Always optimize video for best results
                share_to_feed=share_to_feed
            )
            if not result:
                print(f"Failed to publish reel from {video_path}")
                return None
            print(f"Reel published successfully. ID: {result.get('id')}")
            return result
        except Exception as e:
            print(f"Error publishing reel: {e}")
            import traceback
            print(traceback.format_exc())
            return None
    @staticmethod
    def send_carousel(media_paths, caption, inputs):
        """
        Envia um carrossel de imagens para o Instagram
        Args:
            media_paths (list): Lista de caminhos dos arquivos de mídia (imagens)
            caption (str): Legenda do post
            inputs (dict): Configurações adicionais
        Returns:
            dict: Resultado do envio
        """
        try:
            print(f"[CAROUSEL] Iniciando processamento do carrossel com {len(media_paths)} imagens")
            if len(media_paths) < 2:
                raise Exception(f"Número insuficiente de imagens para criar um carrossel. Encontradas: {len(media_paths)}")
            valid_paths = []
            for path in media_paths:
                if os.path.exists(path):
                    valid_paths.append(path)
                else:
                    print(f"[CAROUSEL] ERRO: Arquivo não encontrado: {path}")
            if len(valid_paths) < 2:
                raise Exception(f"Número insuficiente de imagens válidas para criar um carrossel. Válidas: {len(valid_paths)}")
            print(f"[CAROUSEL] {len(valid_paths)} imagens válidas encontradas, iniciando upload")
            from src.instagram.instagram_carousel_service import InstagramCarouselService
            from src.instagram.carousel_poster import upload_carousel_images
            service = InstagramCarouselService()
            if not service.instagram_account_id or not service.access_token:
                raise Exception("Credenciais do Instagram não configuradas corretamente")
            print(f"[CAROUSEL] Credenciais verificadas, iniciando upload das imagens")
            def progress_update(current, total):
                print(f"[CAROUSEL] Upload de imagens: {current}/{total}")
            success, uploaded_images, image_urls = upload_carousel_images(valid_paths, progress_callback=progress_update)
            print(f"[CAROUSEL] Resultado do upload: success={success}, {len(image_urls)} URLs obtidas")
            if not success:
                raise Exception("Falha no upload de uma ou mais imagens do carrossel")
            if len(image_urls) < 2:
                raise Exception(f"Número insuficiente de URLs para criar um carrossel: {len(image_urls)}")
            print(f"[CAROUSEL] URLs das imagens: {image_urls}")
            print(f"[CAROUSEL] Iniciando publicação do carrossel no Instagram")
            post_id = service.post_carousel(image_urls, caption)
            if not post_id:
                raise Exception("Falha ao publicar o carrossel no Instagram")
            print(f"[CAROUSEL] Carrossel publicado com sucesso! ID: {post_id}")
            return {"status": "success", "post_id": post_id}
        except Exception as e:
            print(f"[CAROUSEL] ERRO: {str(e)}")
            import traceback
            print(traceback.format_exc())
            raise Exception(f"Erro ao enviar carrossel: {e}")
