
â•‘ â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– 
â•‘ â–¶ src/services/send.py
â•‘ â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– 

import os
import time
from dotenv import load_dotenv
from evolutionapi.client import EvolutionClient
from evolutionapi.models.message import TextMessage, MediaMessage
class MessageSender:
    def __init__(self) -> None:
        load_dotenv()
        self.evo_api_token = os.getenv("EVO_API_TOKEN")
        self.evo_instance_id = os.getenv("EVO_INSTANCE_NAME")
        self.evo_instance_token = os.getenv("EVO_INSTANCE_TOKEN")
        self.evo_base_url = os.getenv("EVO_BASE_URL")
        self.client = EvolutionClient(
            base_url=self.evo_base_url,
            api_token=self.evo_api_token
        )
    def send_text(self, number, msg, mentions=[]):
        text_message = TextMessage(
            number=str(number),
            text=msg,
            mentioned=mentions
        )
        time.sleep(10)
        response = self.client.messages.send_text(
            self.evo_instance_id, 
            text_message, 
            self.evo_instance_token
        )
        return response
    def send_pdf(self, number, pdf_file, caption=""):
        if not os.path.exists(pdf_file):
            raise FileNotFoundError(f"Arquivo '{pdf_file}' nÃ£o encontrado.")
        media_message = MediaMessage(
            number=number,
            mediatype="document",
            mimetype="application/pdf",
            caption=caption,
            fileName=os.path.basename(pdf_file),
            media=""
        )
        self.client.messages.send_media(
            self.evo_instance_id, 
            media_message, 
            self.evo_instance_token,
            pdf_file
        )
    def send_audio(self, number, audio_file):
        if not os.path.exists(audio_file):
            raise FileNotFoundError(f"Arquivo '{audio_file}' nÃ£o encontrado.")
        audio_message = {
            "number": number,
            "mediatype": "audio",
            "mimetype": "audio/mpeg",
            "caption": ""
        }
        self.client.messages.send_whatsapp_audio(
            self.evo_instance_id,
            audio_message,
            self.evo_instance_token,
            audio_file
        )
        return "Ãudio enviado"
    def send_image(self, number, image_file, caption=""):
        if not os.path.exists(image_file):
            raise FileNotFoundError(f"Arquivo '{image_file}' nÃ£o encontrado.")
        media_message = MediaMessage(
            number=number,
            mediatype="image",
            mimetype="image/jpeg",
            caption=caption,
            fileName=os.path.basename(image_file),
            media=""
        )
        self.client.messages.send_media(
            self.evo_instance_id, 
            media_message, 
            self.evo_instance_token,
            image_file
        )
        return "Imagem enviada"
    def send_video(self, number, video_file, caption=""):
        if not os.path.exists(video_file):
            raise FileNotFoundError(f"Arquivo '{video_file}' nÃ£o encontrado.")
        media_message = MediaMessage(
            number=number,
            mediatype="video",
            mimetype="video/mp4",
            caption=caption,
            fileName=os.path.basename(video_file),
            media=""
        )
        self.client.messages.send_media(
            self.evo_instance_id, 
            media_message, 
            self.evo_instance_token,
            video_file
        )
        return "VÃ­deo enviado"
    def send_document(self, number, document_file, caption=""):
        if not os.path.exists(document_file):
            raise FileNotFoundError(f"Arquivo '{document_file}' nÃ£o encontrado.")
        media_message = MediaMessage(
            number=number,
            mediatype="document",
            mimetype="application/vnd.openxmlformats-officedocument.wordprocessingml.document",
            caption=caption,
            fileName=os.path.basename(document_file),
            media=""
        )
        self.client.messages.send_media(
            self.evo_instance_id, 
            media_message, 
            self.evo_instance_token,
            document_file
        )
        return "Documento enviado"
sender = MessageSender()
celular = "120363391798069472@g.us"
sender.send_text(number=celular,
                  msg="teste de mensagem")
â•‘ â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– 
â•‘ â–¶ src/services/__init__.py
â•‘ â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– 


â•‘ â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– 
â•‘ â–¶ src/services/message.py
â•‘ â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– 

import base64
class Message:
    TYPE_TEXT = "conversation"
    TYPE_AUDIO = "audioMessage"
    TYPE_IMAGE = "imageMessage"
    TYPE_DOCUMENT = "documentMessage"
    TYPE_VIDEO = "videoMessage"
    SCOPE_GROUP = "group"
    SCOPE_PRIVATE = "private"
    def __init__(self, raw_data):
        if "data" not in raw_data:
            enveloped_data = {
                "event": None,
                "instance": None,
                "destination": None,
                "date_time": None,
                "server_url": None,
                "apikey": None,
                "data": raw_data  # Todo o conteÃºdo simples vai para 'data'
            }
        else:
            enveloped_data = raw_data
        self.data = enveloped_data
        self.extract_common_data()
        self.extract_specific_data()
    def extract_common_data(self):
        """Extrai os dados comuns e define os atributos da classe."""
        self.event = self.data.get("event")
        self.instance = self.data.get("instance")
        self.destination = self.data.get("destination")
        self.date_time = self.data.get("date_time")
        self.server_url = self.data.get("server_url")
        self.apikey = self.data.get("apikey")
        data = self.data.get("data", {})
        key = data.get("key", {})
        self.remote_jid = key.get("remoteJid")
        self.message_id = key.get("id")
        self.from_me = key.get("fromMe")
        self.push_name = data.get("pushName")
        self.status = data.get("status")
        self.instance_id = data.get("instanceId")
        self.source = data.get("source")
        self.message_timestamp = data.get("messageTimestamp")
        self.message_type = data.get("messageType")
        self.sender = data.get("sender")  # DisponÃ­vel apenas para grupos
        self.participant = key.get("participant")  # NÃºmero de quem enviou no grupo
        self.determine_scope()
    def determine_scope(self):
        """Determina se a mensagem Ã© de grupo ou privada e define os atributos correspondentes."""
        if self.remote_jid.endswith("@g.us"):
            self.scope = self.SCOPE_GROUP
            self.group_id = self.remote_jid.split("@")[0]  # ID do grupo
            self.phone = self.participant.split("@")[0] if self.participant else None  # NÃºmero do remetente no grupo
        elif self.remote_jid.endswith("@s.whatsapp.net"):
            self.scope = self.SCOPE_PRIVATE
            self.phone = self.remote_jid.split("@")[0]  # NÃºmero do contato
            self.group_id = None  # NÃ£o Ã© aplicÃ¡vel em mensagens privadas
        else:
            self.scope = "unknown"  # Tipo desconhecido
            self.phone = None
            self.group_id = None
    def extract_specific_data(self):
        """Extrai dados especÃ­ficos e os define como atributos da classe."""
        if self.message_type == self.TYPE_TEXT:
            self.extract_text_message()
        elif self.message_type == self.TYPE_AUDIO:
            self.extract_audio_message()
        elif self.message_type == self.TYPE_IMAGE:
            self.extract_image_message()
        elif self.message_type == self.TYPE_DOCUMENT:
            self.extract_document_message()
        elif self.message_type == self.TYPE_VIDEO:
            self.extract_video_message()
    def extract_text_message(self):
        """Extrai dados de uma mensagem de texto e define como atributos."""
        self.text_message = self.data["data"]["message"].get("conversation")
    def extract_audio_message(self):
        """Extrai dados de uma mensagem de Ã¡udio e define como atributos da classe."""
        audio_data = self.data["data"]["message"]["audioMessage"]
        self.audio_base64_bytes = self.data["data"]["message"].get("base64")
        self.audio_url = audio_data.get("url")
        self.audio_mimetype = audio_data.get("mimetype")
        self.audio_file_sha256 = audio_data.get("fileSha256")
        self.audio_file_length = audio_data.get("fileLength")
        self.audio_duration_seconds = audio_data.get("seconds")
        self.audio_media_key = audio_data.get("mediaKey")
        self.audio_ptt = audio_data.get("ptt")
        self.audio_file_enc_sha256 = audio_data.get("fileEncSha256")
        self.audio_direct_path = audio_data.get("directPath")
        self.audio_waveform = audio_data.get("waveform")
        self.audio_view_once = audio_data.get("viewOnce", False)
    def extract_image_message(self):
        """Extrai dados de uma mensagem de imagem e define como atributos."""
        image_data = self.data["data"]["message"]["imageMessage"]
        self.image_url = image_data.get("url")
        self.image_mimetype = image_data.get("mimetype")
        self.image_caption = image_data.get("caption")
        self.image_file_sha256 = image_data.get("fileSha256")
        self.image_file_length = image_data.get("fileLength")
        self.image_height = image_data.get("height")
        self.image_width = image_data.get("width")
        self.image_media_key = image_data.get("mediaKey")
        self.image_file_enc_sha256 = image_data.get("fileEncSha256")
        self.image_direct_path = image_data.get("directPath")
        self.image_media_key_timestamp = image_data.get("mediaKeyTimestamp")
        self.image_thumbnail_base64 = image_data.get("jpegThumbnail")
        self.image_scans_sidecar = image_data.get("scansSidecar")
        self.image_scan_lengths = image_data.get("scanLengths")
        self.image_mid_quality_file_sha256 = image_data.get("midQualityFileSha256")
        self.image_base64 = self.data["data"]["message"].get("base64")
    def extract_document_message(self):
        """Extrai dados de uma mensagem de documento e define como atributos da classe."""
        document_data = self.data["data"]["message"]["documentMessage"]
        self.document_url = document_data.get("url")
        self.document_mimetype = document_data.get("mimetype")
        self.document_title = document_data.get("title")
        self.document_file_sha256 = document_data.get("fileSha256")
        self.document_file_length = document_data.get("fileLength")
        self.document_media_key = document_data.get("mediaKey")
        self.document_file_name = document_data.get("fileName")
        self.document_file_enc_sha256 = document_data.get("fileEncSha256")
        self.document_direct_path = document_data.get("directPath")
        self.document_caption = document_data.get("caption", None)
        self.document_base64_bytes = self.decode_base64(self.data["data"]["message"].get("base64"))
    def extract_video_message(self):
        """Extrai dados de uma mensagem de vÃ­deo e define como atributos da classe."""
        video_data = self.data["data"]["message"]["videoMessage"]
        self.video_url = video_data.get("url")
        self.video_mimetype = video_data.get("mimetype")
        self.video_caption = video_data.get("caption")
        self.video_file_sha256 = video_data.get("fileSha256")
        self.video_file_length = video_data.get("fileLength")
        self.video_height = video_data.get("height")
        self.video_width = video_data.get("width")
        self.video_media_key = video_data.get("mediaKey")
        self.video_file_enc_sha256 = video_data.get("fileEncSha256")
        self.video_direct_path = video_data.get("directPath")
        self.video_media_key_timestamp = video_data.get("mediaKeyTimestamp")
        self.video_seconds = video_data.get("seconds")
        self.video_streaming_sidecar = video_data.get("streamingSidecar")
        self.video_thumbnail_base64 = video_data.get("jpegThumbnail")
        self.video_gif_playback = video_data.get("gifPlayback", False)
        self.video_view_once = video_data.get("viewOnce", False)
        self.video_base64 = self.data["data"]["message"].get("base64")
    def decode_base64(self, base64_string):
        """Converte uma string base64 em bytes."""
        if base64_string:
            return base64.b64decode(base64_string)
        return None
    def get(self):
        """Retorna todos os atributos como um dicionÃ¡rio."""
        return self.__dict__
    def get_text(self):
        """Retorna o texto da mensagem, dependendo do tipo."""
        text = ""
        if self.message_type == self.TYPE_TEXT:
            text = self.text_message
        elif self.message_type == self.TYPE_IMAGE:
            text = self.image_caption
        elif self.message_type == self.TYPE_DOCUMENT:
            text = self.document_caption
        elif self.message_type == self.TYPE_VIDEO:
            text = self.video_caption
        return text
    def get_name(self):
        """Retorna o nome do remetente."""
        return self.push_name
    @staticmethod
    def get_messages(messages):
        """Retorna uma lista de objetos `Message` a partir de uma lista de mensagens."""
        msgs = messages['messages']['records']
        mensagens = []
        for msg in msgs:
            mensagens.append(Message(msg))
        return mensagens
â•‘ â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– 
â•‘ â–¶ src/services/post_queue.py
â•‘ â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– 

import os
import time
import uuid
import threading
import logging
from queue import Queue, Empty
from threading import Thread
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(name)s - %(levelname)s - %(message)s')
logger = logging.getLogger('PostQueue')
class ContentPolicyViolation(Exception):
    """ExceÃ§Ã£o para violaÃ§Ãµes de polÃ­tica de conteÃºdo"""
class RateLimitExceeded(Exception):
    """ExceÃ§Ã£o para limites de taxa excedidos"""
class PostStatus:
    """Enum-like class to represent post status values"""
    PENDING = "pending"
    PROCESSING = "processing"
    COMPLETED = "completed"
    FAILED = "failed"
    RATE_LIMITED = "rate_limited"
    POLICY_VIOLATION = "policy_violation"
class PostQueue:
    """
    Sistema de filas para processamento assÃ­ncrono de posts e reels
    """
    def __init__(self):
        """Inicializa o sistema de filas"""
        self.job_queue = Queue()
        self.jobs = {}  # Armazena informaÃ§Ãµes sobre os trabalhos
        self.job_history = []  # HistÃ³rico de trabalhos
        self.stats = {
            "total_jobs": 0,
            "completed_jobs": 0,
            "failed_jobs": 0,
            "rate_limited_posts": 0,
            "video_processing_jobs": 0,
            "image_processing_jobs": 0,
            "avg_processing_time": 0
        }
        self.worker_thread = None
        self.is_running = False
        self.processing_lock = threading.Lock()  # Lock para operaÃ§Ãµes crÃ­ticas
        self.start_worker()
    def start_worker(self):
        """Inicia o thread worker para processamento de filas"""
        if not self.is_running:
            self.is_running = True
            self.worker_thread = Thread(target=self._process_queue, daemon=True)
            self.worker_thread.start()
            logger.info("Worker de processamento iniciado")
    def stop_worker(self):
        """Para o thread worker"""
        self.is_running = False
        if self.worker_thread and self.worker_thread.is_alive():
            self.worker_thread.join(timeout=5.0)
            logger.info("Worker de processamento encerrado")
    def add_job(self, media_path, caption, inputs=None) -> str:
        """
        Adiciona um novo trabalho Ã  fila
        Args:
            media_path (str or list): Caminho do arquivo de mÃ­dia ou lista de caminhos
            caption (str): Legenda do post
            inputs (dict): ConfiguraÃ§Ãµes adicionais
        Returns:
            str: ID do trabalho
        """
        job_id = str(uuid.uuid4())
        media_paths = media_path if isinstance(media_path, list) else [media_path]
        content_type = "image"  # default
        if inputs and "content_type" in inputs:
            content_type = inputs["content_type"]  # Use explicit content type if provided
        elif len(media_paths) > 1:
            content_type = "carrossel"
        else:
            path = media_paths[0]
            if isinstance(path, str) and path.lower().endswith(('.mp4', '.mov', '.avi', '.wmv')):
                content_type = "reel"
        job_data = {
            "id": job_id,
            "media_paths": media_paths,
            "caption": caption,
            "inputs": inputs or {},
            "status": "pending",
            "created_at": time.time(),
            "updated_at": time.time(),
            "result": None,
            "error": None,
            "content_type": content_type
        }
        for path in media_paths:
            if not os.path.isfile(path):
                raise FileNotFoundError(f"Media file not found: {path}")
        self.jobs[job_id] = job_data
        self.job_queue.put(job_id)
        with self.processing_lock:
            self.stats["total_jobs"] += 1
            if content_type == "reel":
                self.stats["video_processing_jobs"] += 1
            else:
                self.stats["image_processing_jobs"] += 1
        logger.info(f"Novo trabalho adicionado: {job_id} ({content_type})")
        return job_id
    def _process_queue(self):
        """Thread worker para processar trabalhos na fila"""
        while self.is_running:
            try:
                try:
                    job_id = self.job_queue.get(block=True, timeout=1.0)
                except Empty:
                    continue
                try:
                    logger.info(f"Processando trabalho: {job_id}")
                    job = self.jobs[job_id]
                    self._update_job_status(job_id, "processing")
                    from src.services.instagram_send import InstagramSend
                    start_time = time.time()
                    result = None
                    error = None
                    try:
                        if job["content_type"] == "reel":
                            logger.info(f"Processando vÃ­deo para Reels: {job['media_paths'][0]}")
                            share_to_feed = True
                            if "share_to_feed" in job["inputs"]:
                                share_to_feed = job["inputs"]["share_to_feed"]
                            result = InstagramSend.send_reels(
                                job["media_paths"][0], 
                                job["caption"],
                                job["inputs"]
                            )
                        elif job["content_type"] == "carousel":
                            logger.info(f"Processando carrossel: {job['media_paths']}")
                            result = InstagramSend.send_carousel(
                                job["media_paths"], 
                                job["caption"],
                                job["inputs"]
                            )
                        else:
                            result = InstagramSend.send_instagram(
                                job["media_paths"][0], 
                                job["caption"],
                                job["inputs"]
                            )
                        if result:
                            self._update_job_status(job_id, "completed", result=result)
                            logger.info(f"Trabalho completado: {job_id}")
                            with self.processing_lock:
                                self.stats["completed_jobs"] += 1
                        else:
                            raise Exception("Falha no processamento do conteÃºdo")
                    except RateLimitExceeded as e:
                        error = str(e)
                        logger.warning(f"Rate limit excedido: {error}")
                        self._update_job_status(job_id, "rate_limited", error=error)
                        with self.processing_lock:
                            self.stats["rate_limited_posts"] += 1
                            self.stats["failed_jobs"] += 1
                    except ContentPolicyViolation as e:
                        error = str(e)
                        logger.warning(f"ViolaÃ§Ã£o de polÃ­tica: {error}")
                        self._update_job_status(job_id, "policy_violation", error=error)
                        with self.processing_lock:
                            self.stats["failed_jobs"] += 1
                    except Exception as e:
                        error = str(e)
                        logger.error(f"Erro no processamento: {error}")
                        self._update_job_status(job_id, "failed", error=error)
                        with self.processing_lock:
                            self.stats["failed_jobs"] += 1
                    processing_time = time.time() - start_time
                    with self.processing_lock:
                        if self.stats["completed_jobs"] > 0:
                            current_avg = self.stats["avg_processing_time"]
                            total_processed = self.stats["completed_jobs"]
                            new_avg = ((current_avg * (total_processed - 1)) + processing_time) / total_processed
                            self.stats["avg_processing_time"] = new_avg
                    self._add_to_history(job_id)
                    for media_path in job["media_paths"]:
                        self._cleanup_media(media_path)
                finally:
                    self.job_queue.task_done()
            except Exception as e:
                logger.exception(f"Erro no worker de processamento: {e}")
    def _update_job_status(self, job_id, status, result=None, error=None):
        """Atualiza o status de um trabalho"""
        if job_id in self.jobs:
            self.jobs[job_id]["status"] = status
            self.jobs[job_id]["updated_at"] = time.time()
            if result is not None:
                self.jobs[job_id]["result"] = result
            if error is not None:
                self.jobs[job_id]["error"] = error
    def _add_to_history(self, job_id):
        """Adiciona um trabalho ao histÃ³rico"""
        if job_id in self.jobs:
            job_copy = self.jobs[job_id].copy()
            MAX_HISTORY = 100
            if len(self.job_history) >= MAX_HISTORY:
                self.job_history.pop(0)  # Remover o mais antigo
            self.job_history.append(job_copy)
            self._cleanup_old_jobs()
    def _cleanup_old_jobs(self):
        """Limpa trabalhos antigos"""
        current_time = time.time()
        MAX_AGE = 24 * 60 * 60  # 24 horas
        jobs_to_remove = []
        for job_id, job in self.jobs.items():
            if current_time - job["updated_at"] > MAX_AGE:
                jobs_to_remove.append(job_id)
        for job_id in jobs_to_remove:
            if job_id in self.jobs:
                del self.jobs[job_id]
    def _cleanup_media(self, media_path):
        """Limpa arquivos de mÃ­dia temporÃ¡rios"""
        try:
            if os.path.exists(media_path) and os.path.basename(media_path).startswith("temp-"):
                os.remove(media_path)
                logger.info(f"Arquivo de mÃ­dia temporÃ¡rio removido: {media_path}")
        except Exception as e:
            logger.warning(f"Erro ao limpar arquivo temporÃ¡rio {media_path}: {e}")
    def get_job_status(self, job_id):
        """
        ObtÃ©m o status de um trabalho
        Args:
            job_id (str): ID do trabalho
        Returns:
            dict: InformaÃ§Ãµes do trabalho
        """
        if job_id in self.jobs:
            return self.jobs[job_id].copy()
        for job in self.job_history:
            if job["id"] == job_id:
                return job.copy()
        return {"error": "Job nÃ£o encontrado"}
    def get_queue_stats(self):
        """
        ObtÃ©m estatÃ­sticas da fila
        Returns:
            dict: EstatÃ­sticas da fila
        """
        with self.processing_lock:
            stats = self.stats.copy()
            stats["queue_size"] = self.job_queue.qsize()
            stats["active_jobs"] = len(self.jobs)
            return stats
    def get_job_history(self, limit=10):
        """
        ObtÃ©m histÃ³rico de trabalhos
        Args:
            limit (int): NÃºmero mÃ¡ximo de registros
        Returns:
            list: HistÃ³rico de trabalhos
        """
        return sorted(
            self.job_history,
            key=lambda x: x.get("updated_at", 0),
            reverse=True
        )[:limit]
    def clear_queue(self):
        """Limpa a fila atual de trabalhos"""
        while not self.job_queue.empty():
            try:
                self.job_queue.get(False)
                self.job_queue.task_done()
            except Empty:
                break
        logger.info("Fila limpa")
post_queue = PostQueue()
â•‘ â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– 
â•‘ â–¶ src/services/instagram_send.py
â•‘ â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– â– 

import os
import time
import requests
from src.instagram.crew_post_instagram import InstagramPostCrew
from src.instagram.describe_image_tool import ImageDescriber
from src.instagram.instagram_post_service import InstagramPostService
from src.instagram.border import ImageWithBorder
from src.instagram.filter import FilterImage
from src.utils.paths import Paths
from src.instagram.image_uploader import ImageUploader
from src.services.post_queue import post_queue, RateLimitExceeded
class InstagramSend:
    last_rate_limit_time = 0
    rate_limit_window = 3600  # 1 hour window for rate limiting
    max_rate_limit_hits = 52  # Maximum number of rate limit hits before enforcing longer delays
    @staticmethod
    def queue_post(image_path, caption, inputs=None) -> str:
        """
        Queue an image to be posted to Instagram asynchronously
        Args:
            image_path (str): Path to the image file
            caption (str): Caption text
            inputs (dict): Optional configuration for post generation
        Returns:
            str: Job ID for tracking the post status
        """
        if not caption or caption.lower() == "none":
            caption = "A AcessoIA estÃ¡ transformando processos com IA! ğŸš€"
            print(f"Caption vazia ou 'None'. Usando caption padrÃ£o: '{caption}'")
        if not os.path.exists(image_path):
            raise FileNotFoundError(f"Arquivo de imagem nÃ£o encontrado: {image_path}")
        job_id = post_queue.add_job(image_path, caption, inputs)
        return job_id
    @staticmethod
    def queue_reels(video_path, caption, inputs=None) -> str:
        """
        Queue a video to be posted to Instagram as a reel asynchronously
        Args:
            video_path (str): Path to the video file
            caption (str): Caption text
            inputs (dict): Optional configuration for post generation
        Returns:
            str: Job ID for tracking the post status
        """
        if not caption or caption.lower() == "none":
            caption = "A AcessoIA estÃ¡ transformando processos com IA! ğŸš€ #reels #ai"
            print(f"Caption vazia ou 'None'. Usando caption padrÃ£o para reels: '{caption}'")
        if not os.path.exists(video_path):
            raise FileNotFoundError(f"Arquivo de vÃ­deo nÃ£o encontrado: {video_path}")
        if inputs is None:
            inputs = {}
        inputs["content_type"] = "reel"
        inputs["video_path"] = video_path
        print(f"Caption in queue_reels: {caption}")  # Debug statement
        job_id = post_queue.add_job(video_path, caption, inputs)
        print(f"Reel queued with job ID: {job_id}")
        return job_id
    @staticmethod
    def queue_carousel(image_paths, caption, inputs=None):
        """
        Enfileira um carrossel de imagens para o Instagram
        Args:
            image_paths (list): Lista de caminhos dos arquivos de mÃ­dia (imagens)
            caption (str): Legenda do post
            inputs (dict): ConfiguraÃ§Ãµes adicionais
        Returns:
            str: ID do trabalho
        """
        job_id = post_queue.add_job(image_paths, caption, inputs)
        return job_id
    @staticmethod
    def check_post_status(job_id):
        """
        Check the status of a queued post
        Args:
            job_id (str): Job ID returned when queuing the post
        Returns:
            dict: Job status information
        """
        return post_queue.get_job_status(job_id)
    @staticmethod
    def get_queue_stats():
        """
        Get statistics about the current queue
        Returns:
            dict: Queue statistics
        """
        return post_queue.get_queue_stats()
    @staticmethod
    def get_recent_posts(limit=10):
        """
        Get recent post history
        Args:
            limit (int): Maximum number of posts to return
        Returns:
            list: Recent post history
        """
        return post_queue.get_job_history(limit)
    @staticmethod
    def send_instagram(image_path, caption, inputs=None):
        """
        Send an image to Instagram with a caption.
        Args:
            image_path (str): Path to the image file
            caption (str): Caption text
            inputs (dict): Optional configuration for post generation
        """
        result = None
        original_image_path = image_path
        uploaded_images = []
        uploader = ImageUploader()  # Reuse the same uploader instance
        if not caption or caption.lower() == "none":
            caption = "A AcessoIA estÃ¡ transformando processos com IA! ğŸš€"
            print(f"Caption vazia ou 'None'. Usando caption padrÃ£o: '{caption}'")
        try:
            if inputs is None:
                inputs = {
                    "estilo": "Divertido, Alegre, SarcÃ¡stico e descontraÃ­do",
                    "pessoa": "Terceira pessoa do singular",
                    "sentimento": "Positivo",
                    "tamanho": "200 palavras",
                    "genero": "Neutro",
                    "emojs": "sim",
                    "girias": "sim"
                }
            if not os.path.exists(image_path):
                raise FileNotFoundError(f"Arquivo de imagem nÃ£o encontrado: {image_path}")
            border_image = os.path.join(Paths.SRC_DIR, "instagram", "moldura.png")
            print("Aplicando filtros Ã  imagem...")
            image_path = FilterImage.process(image_path)
            print("Obtendo descriÃ§Ã£o da imagem...")
            try:
                temp_image = uploader.upload_from_path(image_path)
                uploaded_images.append(temp_image)
                describe = ImageDescriber.describe(temp_image['url'])
                if temp_image.get("deletehash"):
                    print(f"Deletando imagem temporÃ¡ria usada para descriÃ§Ã£o...")
                    if uploader.delete_image(temp_image["deletehash"]):
                        uploaded_images.remove(temp_image)
            except Exception as e:
                print(f"Erro ao obter descriÃ§Ã£o da imagem: {str(e)}")
                describe = "Imagem para publicaÃ§Ã£o no Instagram."
            print("Aplicando bordas e filtros...")
            try:
                image = ImageWithBorder.create_bordered_image(
                    border_path=border_image,
                    image_path=image_path,
                    output_path=image_path                
                )
            except Exception as e:
                print(f"Erro ao aplicar borda Ã  imagem: {str(e)}")
            print("Enviando imagem para publicaÃ§Ã£o...")
            try:
                final_image = uploader.upload_from_path(image_path)
                uploaded_images.append(final_image)
            except Exception as e:
                print(f"Erro ao fazer upload da imagem final: {str(e)}")
                raise
            print("Gerando legenda...")
            try:
                crew = InstagramPostCrew()
                inputs_dict = {
                    "genero": inputs.get('genero', 'Neutro'),
                    "caption": caption,
                    "describe": describe,
                    "estilo": inputs.get('estilo', 'Divertido, Alegre, SarcÃ¡stico e descontraÃ­do'),
                    "pessoa": inputs.get('pessoa', 'Terceira pessoa do singular'),
                    "sentimento": inputs.get('sentimento', 'Positivo'),
                    "tamanho": inputs.get('tamanho', '200 palavras'),
                    "emojs": inputs.get('emojs', 'sim'),
                    "girias": inputs.get('girias', 'sim')
                }
                final_caption = crew.kickoff(inputs=inputs_dict)  # Passar o dicionÃ¡rio
            except Exception as e:
                print(f"Erro ao gerar legenda: {str(e)}")
                final_caption = caption  # Usar a legenda original em caso de erro
            final_caption = final_caption + "\n\n-------------------"
            final_caption = final_caption + "\n\n Essa postagem foi toda realizada por um agente inteligente"
            final_caption = final_caption + "\n O agente desempenhou as seguintes aÃ§Ãµes:"
            final_caption = final_caption + "\n 1 - IdenficaÃ§Ã£o e reconhecimento do ambiente da fotografia"
            final_caption = final_caption + "\n 2 - AplicaÃ§Ã£o de Filtros de contraste e autocorreÃ§Ã£o da imagem"
            final_caption = final_caption + "\n 3 - AplicaÃ§Ã£o de moldura especÃ­fica"
            final_caption = final_caption + "\n 4 - DefiniÃ§Ã£o de uma persona especÃ­fica com base nas preferÃªncias"
            final_caption = final_caption + "\n 5 - CriaÃ§Ã£o da legenda com base na imagem e na persona"
            final_caption = final_caption + "\n 6 - Postagem no feed do instagram"
            final_caption = final_caption + "\n\n-------------------"
            print("Iniciando processo de publicaÃ§Ã£o no Instagram...")
            try:
                insta_post = InstagramPostService()
                stats = post_queue.get_queue_stats()
                current_time = time.time()
                if stats["rate_limited_posts"] > InstagramSend.max_rate_limit_hits:
                    if (current_time - InstagramSend.last_rate_limit_time) < InstagramSend.rate_limit_window:
                        remaining_time = InstagramSend.rate_limit_window - (current_time - InstagramSend.last_rate_limit_time)
                        raise RateLimitExceeded(
                            f"Taxa de requisiÃ§Ãµes severamente excedida. "
                            f"Aguarde {int(remaining_time/60)} minutos antes de tentar novamente."
                        )
                    else:
                        InstagramSend.last_rate_limit_time = 0
                        stats["rate_limited_posts"] = 0
                result = insta_post.post_image(final_image['url'], final_caption)
                if not result:
                    print("Falha ao publicar no Instagram. Verificando status...")
                    raise Exception("Falha na publicaÃ§Ã£o")
                print("Post processado e enviado ao Instagram com sucesso!")
                return result
            except Exception as e:
                error_str = str(e).lower()
                if "rate" in error_str and "limit" in error_str:
                    InstagramSend.last_rate_limit_time = current_time
                    raise RateLimitExceeded(f"Taxa de requisiÃ§Ãµes excedida: {str(e)}")
                print(f"Erro no processo de publicaÃ§Ã£o no Instagram: {str(e)}")
                raise
        except Exception as e:
            print(f"Erro durante o processo de publicaÃ§Ã£o: {str(e)}")
            return None
        finally:
            try:
                failed_deletions = []
                for img in uploaded_images:
                    try:
                        if img.get("deletehash"):
                            print(f"Tentando deletar imagem com deletehash: {img.get('deletehash')}...")
                            if not uploader.delete_image(img["deletehash"]):
                                failed_deletions.append(img["deletehash"])
                    except requests.exceptions.HTTPError as e:
                        if hasattr(e, 'response') and e.response.status_code == 404:
                            print("Imagem jÃ¡ removida do servidor.")
                        else:
                            print(f"Erro ao deletar imagem: {str(e)}")
                    except Exception as e:
                        print(f"Erro ao deletar imagem: {str(e)}")
                if failed_deletions:
                    print("Aviso: Algumas imagens nÃ£o puderam ser deletadas:")
                    for failed_hash in failed_deletions:
                        print(f"- Deletehash: {failed_hash}")
                if image_path and image_path != original_image_path and os.path.exists(image_path):
                    os.remove(image_path)
                    print(f"A imagem local {image_path} foi apagada com sucesso.")
            except Exception as cleanup_error:
                print(f"Erro ao limpar arquivos temporÃ¡rios: {str(cleanup_error)}")
        return result
    @staticmethod
    def send_reels(video_path, caption, inputs=None):
        """
        Send a video to Instagram as a Reel
        Args:
            video_path (str): Path to the video file
            caption (str): Caption text
            inputs (dict): Optional configuration for post generation
        Returns:
            dict: Result information including post ID and URL
        """
        from src.instagram.instagram_reels_publisher import ReelsPublisher
        try:
            publisher = ReelsPublisher()
            hashtags = None
            if inputs and 'hashtags' in inputs:
                hashtags = inputs['hashtags']
            share_to_feed = True
            if inputs and 'share_to_feed' in inputs:
                share_to_feed = inputs['share_to_feed']
            result = publisher.upload_local_video_to_reels(
                video_path=video_path,
                caption=caption,
                hashtags=hashtags,
                optimize=True,  # Always optimize video for best results
                share_to_feed=share_to_feed
            )
            if not result:
                print(f"Failed to publish reel from {video_path}")
                return None
            print(f"Reel published successfully. ID: {result.get('id')}")
            return result
        except Exception as e:
            print(f"Error publishing reel: {e}")
            import traceback
            print(traceback.format_exc())
            return None
    @staticmethod
    def send_carousel(media_paths, caption, inputs):
        """
        Envia um carrossel de imagens para o Instagram
        Args:
            media_paths (list): Lista de caminhos dos arquivos de mÃ­dia (imagens)
            caption (str): Legenda do post
            inputs (dict): ConfiguraÃ§Ãµes adicionais
        Returns:
            dict: Resultado do envio
        """
        try:
            print(f"[CAROUSEL] Iniciando processamento do carrossel com {len(media_paths)} imagens")
            if len(media_paths) < 2:
                raise Exception(f"NÃºmero insuficiente de imagens para criar um carrossel. Encontradas: {len(media_paths)}")
            valid_paths = []
            for path in media_paths:
                if os.path.exists(path):
                    valid_paths.append(path)
                else:
                    print(f"[CAROUSEL] ERRO: Arquivo nÃ£o encontrado: {path}")
            if len(valid_paths) < 2:
                raise Exception(f"NÃºmero insuficiente de imagens vÃ¡lidas para criar um carrossel. VÃ¡lidas: {len(valid_paths)}")
            print(f"[CAROUSEL] {len(valid_paths)} imagens vÃ¡lidas encontradas, iniciando upload")
            from src.instagram.instagram_carousel_service import InstagramCarouselService
            from src.instagram.carousel_poster import upload_carousel_images
            service = InstagramCarouselService()
            if not service.instagram_account_id or not service.access_token:
                raise Exception("Credenciais do Instagram nÃ£o configuradas corretamente")
            print(f"[CAROUSEL] Credenciais verificadas, iniciando upload das imagens")
            def progress_update(current, total):
                print(f"[CAROUSEL] Upload de imagens: {current}/{total}")
            success, uploaded_images, image_urls = upload_carousel_images(valid_paths, progress_callback=progress_update)
            print(f"[CAROUSEL] Resultado do upload: success={success}, {len(image_urls)} URLs obtidas")
            if not success:
                raise Exception("Falha no upload de uma ou mais imagens do carrossel")
            if len(image_urls) < 2:
                raise Exception(f"NÃºmero insuficiente de URLs para criar um carrossel: {len(image_urls)}")
            print(f"[CAROUSEL] URLs das imagens: {image_urls}")
            print(f"[CAROUSEL] Iniciando publicaÃ§Ã£o do carrossel no Instagram")
            post_id = service.post_carousel(image_urls, caption)
            if not post_id:
                raise Exception("Falha ao publicar o carrossel no Instagram")
            print(f"[CAROUSEL] Carrossel publicado com sucesso! ID: {post_id}")
            return {"status": "success", "post_id": post_id}
        except Exception as e:
            print(f"[CAROUSEL] ERRO: {str(e)}")
            import traceback
            print(traceback.format_exc())
            raise Exception(f"Erro ao enviar carrossel: {e}")
